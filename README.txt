attack.py: Attack script for payload-based covert channel 

attack2.py: Attack script for IPID-based covert channel

client.py: Bot script for payload-based covert channel

client2.py: Bot script for IPID-based covert channel

IDS.py: Intrusion detection system script (functionality for both payload and IP header field detection channels)


=============================================================

Instructions:

2.2 Setting up the Virtual Machines==================================

To clone the project source code to a VM, run the command:
scp -P 8246 -r CS4404-Mission3-main/ student@secnet-gateway.cs.wpi.edu:~/


Where 8246 is the port of the VM and CS4404-Mission3-main is the project directory.

In order to connect to a VM and keep the connection alive while idle, run the command:
ssh -o ServerAliveInterval=20 -p 8246 student@secnet-gateway.cs.wpi.edu

And then enter user credentials when prompted.

2.3 Client=============================

The client contains 3 files, all located within the client/ directory. client.py and client2.py are both implementations of the bot, each utilizing a different attack vector for use in the attack phase. Both will generate cover traffic to simulate normal ping requests and replies to and from the adversary. 

The file secret.txt represents sensitive organizational data, and contains the string “thequickbrownfoxjumpsoverthelazydog”. If this data is transferred to the adversary, it can be considered as sensitive information being exfiltrated outside of the organization to a remote attacker.

In order to simulate an organizational network secured by an IPS, all traffic generated by the client must go through the IPS. This can be done by adding routing rules that send all outbound traffic through the IPS. Because VM 3 and VM 4 are the only machines outside of the organization’s network, add them to the routing rules by running the command:
route add -host 10.64.13.3 gw 10.64.13.2
route add -host 10.64.13.4 gw 10.64.13.2

This will route all traffic outbound for the other machines through the IPS at 10.64.13.2.

To launch the bot script, run the command:
python3 client.py

and this will start the bot script. Sudo privileges may be required for the Scapy modules to function properly. The bot script will also include cover traffic, namely occasional ping requests, to simulate actual traffic that would occur under normal circumstances in a network.

2.4 Intrusion Prevention System=========================

The Intrusion Prevention System utilizes python Scapy modules to capture, analyze, and allow traffic through. All of the necessary files are provided in the defense/ directory. The IDS.py file represents the IPS system for use in the defense phase.

Because the IPS handles all of the packets it receives, IP forwarding should be disabled on the IPS machine, otherwise packets will automatically forward to their destination without the IPS’ control or approval. This can be done by running the command:
echo 0 > /proc/sys/net/ipv4/ip_forward


To run the IPS system, first configure the python file and change two variables at the top of the file: interface and Device_IP. They should be the name of the network interface you are using and the device’s IP address, respectively. For our setup, interface="ens3" and Device_IP="10.64.13.2". After the IPS is configured properly, start it by running the command:
python3 IDS.py

Sample output from this program is shown in Figure 2.4.1.

This will begin the intrusion prevention system. It will display a log containing a brief summary of all packets it allows through. When a threat or unusual packet is detected, it will warn the user by displaying the entire contents of the packet, along with a reason for why the packet was marked for prevention.

To determine whether a packet flagged as malicious was a true positive or a false positive, the IDS script prints out the contents of the entire packet as well as a justification as to why it selected the packet. A network administrator would be able to discern why the IDS flagged the packet as malicious and see if the contents of the packet were indeed malicious or not, to determine if it was a true or false positive. This is akin to the alerts that Bro and Snort send to network administrators on each violation of a user-defined rule. 

2.5 Adversary=============================================

The adversary files are contained within the attack/ directory. The files are attack.py and attack2.py, which represent two different attack vectors for the attack phase, similar to the client. These files simulate the C2 center that the adversary uses to issue commands to the bot and receive replies containing data from the bot.

In order to simulate the organizational network being secured by the IPS, all traffic inbound for the client from the outside must go through the IPS. So any traffic the adversary attempts to send to the client must be routed through the IPS. This can be done by adding the following routing rule through running the command:
route add -host 10.64.13.1 gw 10.64.13.2

This command will send all traffic outbound from the adversary to the client through the IPS.

To run the C2 center, select either script and edit the top three variables, destIP, srcIP, and interface to represent the destination IP address of the client, the source IP address of the adversary machine you are running the script on, and the name of the network interface you are using.

After configuring the file, run the C2 script with the command:
python3 attack.py

The adversary will then be prompted for a command to send to the bot. After each command is run, a 1 second delay is incurred between each prompt. To exit the script, you will need to terminate the process by inputting Ctrl-C to stop it. 

There are two possible commands the adversary can execute, !secret and !command. The !secret command will instruct the bot to retrieve the data in the secret.txt file located on the client’s machine, and send the data back to the adversary’s machine. When the adversary runs the !command command, they will be prompted to enter an actual terminal command. The terminal command will then be sent to the bot, who will then attempt to execute the command they received from the adversary. The bot will then send back the output of running the command back to the adversary, which will be displayed and can be inspected or stored for further analysis.




